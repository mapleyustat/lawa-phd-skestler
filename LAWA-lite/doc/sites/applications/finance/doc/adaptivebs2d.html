<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/1998/REC-html40-19980424/strict.dtd">
<html>
<head>
<title>LAWA - Library for Adaptive Wavelet Applications</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link type="text/css" href="../../../default.css" rel=stylesheet>

<script type="text/javascript">
  MathJax.Hub.Config({
     extensions: ["tex2jax.js"],
     tex2jax: {
         inlineMath: [ ['$','$']/*, ["\\(","\\)"]*/ ],
         displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
         processEscapes: true
     },
     "HTML-CSS": { scale: 100 }
  });
</script>

<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


</head>
<body>
<script type="text/javascript" src="../../../wz_tooltip.js"></script>

<div id="body">
<div id="header">
    <div id="slogan">LAWA <br> L<span class="fade">ibrary for </span>
                               A<span class="fade">daptive </span>
                               W<span class="fade">avelet </span>
                               A<span class="fade">pplications </span>
    <div id="wavelet"><img src="../../../../images/wavelet.png" 
         style="float:right" height="160px" alt="wavelet.png"></div></div>
</div>

<div id="content">
<!--<table width="100%">
<tr>
<td valign="top" id="leftmenu">-->
<div id="leftmenu">
<ul id="menu">
<li class="subtitle">lawa</li>
<li><a href="../../../index.html">home</a></li>
<li><a href="../../../doc/license.html">license</a></li>
<li><a href="../../../doc/roadmap.html">roadmap</a></li>

<li class="subtitle">features</li>
<li><a href="../../../doc/features.html">lawa features</a></li>
<li><a href="../../../doc/highperformance.html">high performance</a></li>
<li><a href="../../../doc/convenientusage.html">convenient usage</a></li>

<li class="subtitle">using lawa</li>
<li><a href="../../../doc/download.html">download</a></li>
<li><a href="../../../lawa/lawa.html">documentation</a></li>
<!--<li><a href="/doc/contributingcode.html">contributing code</a></li>-->
<li><a href="../../../doc/mailinglist.html">mailing list</a></li>
<li><a href="../../../doc/reportingbugs.html">reporting bugs</a></li>

    <li class="subtitle">projects</li>
    <li><a href="../../../doc/projects.html">based on / using lawa</a></li>
</ul>
<!--</td>
<td class="main">-->
</div><div id="main">

<p >
     <a href="../../applications.html">PhD thesis by S.K.</a> - <a href="../../finance.html">Wavelet Galerkin methods in numerical finance</a> - <a href="adaptivebs2d.html">Adaptive discretization of the two-dimensional Black-Scholes problem</a></p>

<h3 class="doc">
Adaptive discretization of the two-dimensional Black-Scholes problem</h3>

<p >
     Source file <tt>applications/finance/bs2d_multitree_mw_awgm.cpp</tt></p><p >
     For the domain \([-R,R]^2\), we consider the adaptive discretization of the two-dimensional Black-Scholes problem Eq. (8.124) by \(L_2\)-orthonormal multiwavelets. As described in Section 8.6.3, the usage of this basis has certain advantages compared to biorthogonal wavelets. This is why this program only works for this construction.</p><p >
     Moreover, we make specific use of the multitree algorithms described in Chapters 6 and 7.</p><p >
     Basis definitions</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">typedef</span>&nbsp;Basis&lt;T,Orthogonal,Interval,Multi&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PrimalBasis;<br>
<!-- CodeLine     2 --><span style="color:#008000">typedef</span>&nbsp;PrimalBasis::RefinementBasis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RefinementBasis;<br>
<!-- CodeLine     3 --><span style="color:#008000">typedef</span>&nbsp;TensorBasis2D&lt;Adaptive,PrimalBasis,PrimalBasis&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Basis2D;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Values for strike, maturity and weights for the assets \(S_1\), \(S_2\)</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->T strike =&nbsp;<span style="color:#c00000">1.</span>;<br>
<!-- CodeLine     2 -->T maturity =&nbsp;<span style="color:#c00000">1.</span>;<br>
<!-- CodeLine     3 -->T weight1 =&nbsp;<span style="color:#c00000">0.5</span>, weight2 =&nbsp;<span style="color:#c00000">0.5</span>;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Definition of the option type</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">const</span>&nbsp;OptionTypenD optiontype = BasketPut;<br>
<!-- CodeLine     2 -->OptionParameters2D&lt;T,BasketPut&gt; optionparameters(strike, maturity, weight1, weight2,&nbsp;<span style="color:#c00000">false</span>);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Definition of an integral type for approximating the initial condition (transformed payoff function) associated to the above defined option type using a full tensor product rule</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">typedef</span>&nbsp;PayoffIntegral2D&lt;FullGridGL,Basis2D,TruncatedBasketPutOption2D&lt;T&gt; &gt; PayoffIntegral;<br>
<!-- CodeLine     2 --><span style="color:#008000">typedef</span>&nbsp;RHS2D&lt;T, PayoffIntegral, NoPreconditioner&lt;T, Index2D&gt;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PayoffIntegralRHS;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Definition of the process type: Here (for the moment) only two-dimensional Black-Scholes model</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">const</span>&nbsp;ProcessType2D&nbsp;&nbsp;processtype&nbsp;&nbsp;= BlackScholes2D;<br>
<!-- CodeLine     2 --><span style="color:#8080ff">//T r = 0.04; T sigma1 = 0.3, sigma2 = 0.2, rho = 0.;</span><br>
<!-- CodeLine     3 --><span style="color:#8080ff">//T u11 = 1., u12 = 0., u21 = 0., u22 = 1.;</span><br>
<!-- CodeLine     4 -->T r =&nbsp;<span style="color:#c00000">0.</span>;<br>
<!-- CodeLine     5 -->T sigma1 =&nbsp;<span style="color:#c00000">0.3</span>;<br>
<!-- CodeLine     6 -->T sigma2 =&nbsp;<span style="color:#c00000">0.2</span>;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Correlation and definition of the matrix \(U\) from p. 178</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#8080ff">//T rho = 0.;</span><br>
<!-- CodeLine     2 --><span style="color:#8080ff">//T u11 = 1., u12 = 0., u21 = 0., u22 = 1.;</span><br>
<!-- CodeLine     3 --><span style="color:#8080ff">//T s1&nbsp;&nbsp;= sigma1*sigma1, s2&nbsp;&nbsp;= sigma2*sigma2;</span><br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Storing the process parameters</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->ProcessParameters2D&lt;T,BlackScholes2D&gt;&nbsp;&nbsp; processparameters(r, sigma1, sigma2, rho, u11, u12, u21, u22);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Definition of (optimized) wavelet preconditioner</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">typedef</span>&nbsp;OptimizedH1Preconditioner2D&lt;T,Basis2D&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Preconditioner;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Underlying bilinear form</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">typedef</span>&nbsp;RefinementBasis::LaplaceOperator1D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RefinementLaplaceOp1D;<br>
<!-- CodeLine     2 --><span style="color:#008000">typedef</span>&nbsp;RefinementBasis::IdentityOperator1D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RefinementIdentityOp1D;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Definition of the underlying bilinear form. The identity operator is solely for debugging purposes in case. In particular, when the multitree constraint on the index is violated, this can be checked by means of this operator quite easily.</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">typedef</span>&nbsp;LocalOperator1D&lt;PrimalBasis,PrimalBasis,<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RefinementLaplaceOp1D&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalOp1D;<br>
<!-- CodeLine     3 --><span style="color:#008000">typedef</span>&nbsp;LocalOperator1D&lt;PrimalBasis,PrimalBasis,<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RefinementIdentityOp1D&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LocalIdentityOp1D;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Corresponding 2d local operators</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">typedef</span>&nbsp;UniDirectionalLocalOperator&lt;Index2D,XOne,LocalOp1D,<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NotXOne,Index1D&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UniDirectionalLocalOpXOne2D;<br>
<!-- CodeLine     3 --><span style="color:#008000">typedef</span>&nbsp;UniDirectionalLocalOperator&lt;Index2D,XTwo,LocalOp1D,<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NotXTwo,Index1D&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UniDirectionalLocalOpXTwo2D;<br>
<!-- CodeLine     5 --><span style="color:#008000">typedef</span>&nbsp;UniDirectionalLocalOperator&lt;Index2D,XOne,LocalIdentityOp1D,<br>
<!-- CodeLine     6 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NotXOne,Index1D&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UniDirectionalLocalIdentityOpXOne2D;<br>
<!-- CodeLine     7 --><span style="color:#008000">typedef</span>&nbsp;UniDirectionalLocalOperator&lt;Index2D,XTwo,LocalIdentityOp1D,<br>
<!-- CodeLine     8 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NotXTwo,Index1D&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UniDirectionalLocalIdentityOpXTwo2D;<br>
<!-- CodeLine     9 --><span style="color:#008000">typedef</span>&nbsp;CompoundLocalOperator&lt;Index2D, UniDirectionalLocalOpXOne2D,<br>
<!-- CodeLine    10 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UniDirectionalLocalOpXTwo2D&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompoundLocalOperator2D;<br>
<!-- CodeLine    11 --><span style="color:#008000">typedef</span>&nbsp;CompoundLocalOperator&lt;Index2D,<br>
<!-- CodeLine    12 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UniDirectionalLocalIdentityOpXOne2D,<br>
<!-- CodeLine    13 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UniDirectionalLocalIdentityOpXTwo2D&gt;&nbsp;&nbsp;CompoundLocalIdentityOperator2D;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Local operator for the time-stepping scheme (see, e.g., Eq. (8.73))</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">typedef</span>&nbsp;ThetaTimeStepLocalOperator&lt;Index2D, CompoundLocalOperator2D,<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CompoundLocalIdentityOperator2D&gt; ThetaTimeStepLocalOperator2D;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Required right-hand side definitions</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">typedef</span>&nbsp;RHSWithPeaks1D&lt;T,PrimalBasis&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rhs1D;<br>
<!-- CodeLine     2 --><span style="color:#008000">typedef</span>&nbsp;AdaptiveSeparableRhs&lt;T,Index2D,Rhs1D,Rhs1D &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AdaptiveSeparableRhsIntegral2D;<br>
<!-- CodeLine     3 --><span style="color:#008000">typedef</span>&nbsp;ThetaTimeStepSeparableRHS&lt;T,Index2D,<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AdaptiveSeparableRhsIntegral2D,<br>
<!-- CodeLine     5 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThetaTimeStepLocalOperator2D&gt;&nbsp;&nbsp;&nbsp;&nbsp; ThetaTimeStepRhs2d;<br>
<!-- CodeLine     6 --><span style="color:#008000">typedef</span>&nbsp;CompoundRhs&lt;T,Index2D,AdaptiveSeparableRhsIntegral2D,<br>
<!-- CodeLine     7 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AdaptiveSeparableRhsIntegral2D&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CompoundRhsIntegral2D;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Definition of multitree AWGM solver for solving the linear system in each time-step.</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">typedef</span>&nbsp;MultiTreeAWGM&lt;Index2D,Basis2D,ThetaTimeStepLocalOperator2D,<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThetaTimeStepRhs2d,Preconditioner&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThetaTimeStepMultiTreeAWGM2D;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Definiton of a class that realizes the local weighting of residual as proposed in Eq. (8.126)</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">typedef</span>&nbsp;LocalWeighting2D&lt;T, Basis2D&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalWeightingInitCond2D;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Definition of multitree AWGM solver for approximating the initial condition.</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">typedef</span>&nbsp;MultiTreeAWGM&lt;Index2D,Basis2D,<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThetaTimeStepLocalOperator2D,<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PayoffIntegralRHS,<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NoPreconditioner&lt;T,Index2D&gt; &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ApproxL2AWGM2D;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Definition of the \(\theta\)-scheme AWGM sovler</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">typedef</span>&nbsp;ThetaSchemeAWGM&lt;Index2D, ThetaTimeStepMultiTreeAWGM2D&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThetaSchemeMultiTreeAWGM2D;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     A simple routine to evaluate a wavelet basis expansion on the domain \([-R_1,R_1] \times [-R_2,R_2]\)</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->T<br>
<!-- CodeLine     2 -->evaluate(<span style="color:#008000">const</span>&nbsp;Basis2D &amp;basis2d, T left_x1, T right_x1, T left_x2, T right_x2,<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">const</span>&nbsp;Coefficients&lt;Lexicographical,T,Index2D&gt; &amp;v, T x1, T x2);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Computing the \(L_\infty\) error as described in Eq. (8.125). There, you also find the definition of \(\delta\).</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->T<br>
<!-- CodeLine     2 -->computeLinftyError(<span style="color:#008000">const</span>&nbsp;Basis2D &amp;basis2d, T left_x1, T right_x1, T left_x2, T right_x2,<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">const</span>&nbsp;Coefficients&lt;Lexicographical,T,Index2D&gt; &amp;u,T delta,&nbsp;<span style="color:#008000">int</span>&nbsp;j,<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Option2D&lt;T,optiontype&gt; &amp;option2d,<br>
<!-- CodeLine     5 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessParameters2D&lt;T,BlackScholes2D&gt; &amp;processparameters);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Same as above when reference prices are used and not computed by Monte-Carlo simulation</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->T<br>
<!-- CodeLine     2 -->computeLinftyError(<span style="color:#008000">const</span>&nbsp;Basis2D &amp;basis2d, T left_x1, T right_x1, T left_x2, T right_x2,<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">const</span>&nbsp;Coefficients&lt;Lexicographical,T,Index2D&gt; &amp;u,T delta,&nbsp;<span style="color:#008000">int</span>&nbsp;j,<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Option2D&lt;T,optiontype&gt; &amp;option2d,<br>
<!-- CodeLine     5 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessParameters2D&lt;T,BlackScholes2D&gt; &amp;processparameters,<br>
<!-- CodeLine     6 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">const</span>&nbsp;std::map&lt;std::pair&lt;T,T&gt;,T&gt; &amp;refprices);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Compute reference prices (by MC simulation if no closed formula is available)</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">void</span><br>
<!-- CodeLine     2 -->computeReferencePrice(<span style="color:#008000">const</span>&nbsp;Basis2D &amp;basis2d, T left_x1, T right_x1, T left_x2, T right_x2,<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T inner_left1, T inner_right1, T inner_left2, T inner_right2, T h1, T h2,<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">const</span>&nbsp;Coefficients&lt;Lexicographical,T,Index2D&gt; &amp;u,&nbsp;<span style="color:#008000">int</span>&nbsp;j,<br>
<!-- CodeLine     5 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Option2D&lt;T,optiontype&gt; &amp;option2d,<br>
<!-- CodeLine     6 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessParameters2D&lt;T,BlackScholes2D&gt; &amp;processparameters);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Read reference prices from file since high-precision MC simulations can be quite costly</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 --><span style="color:#008000">void</span><br>
<!-- CodeLine     2 -->readReferencePrice(<span style="color:#008000">const</span>&nbsp;Basis2D &amp;basis2d, T left_x1, T right_x1, T left_x2, T right_x2,<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T inner_left1, T inner_right1, T inner_left2, T inner_right2, T h1, T h2,<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">const</span>&nbsp;Coefficients&lt;Lexicographical,T,Index2D&gt; &amp;u,&nbsp;<span style="color:#008000">int</span>&nbsp;j,<br>
<!-- CodeLine     5 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Option2D&lt;T,optiontype&gt; &amp;option2d,<br>
<!-- CodeLine     6 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessParameters2D&lt;T,BlackScholes2D&gt; &amp;processparameters,<br>
<!-- CodeLine     7 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::map&lt;std::pair&lt;T,T&gt;,T&gt; &amp;refprices);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Wavelet basis parameters</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">int</span>&nbsp;d&nbsp;&nbsp; = atoi(argv[<span style="color:#c00000">1</span>]);<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">int</span>&nbsp;j0&nbsp;&nbsp;= atoi(argv[<span style="color:#c00000">2</span>]);<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">int</span>&nbsp;J&nbsp;&nbsp;= atoi(argv[<span style="color:#c00000">3</span>]);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Parameters for AWGM: here only dummy variables</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;T alpha =&nbsp;<span style="color:#c00000">0.4</span>;<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;T gamma =&nbsp;<span style="color:#c00000">0.025</span>;<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">const</span>&nbsp;<span style="color:#008000">char</span>* residualType =&nbsp;<span style="color:#c00000">&quot;standard&quot;</span>;<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">const</span>&nbsp;<span style="color:#008000">char</span>* treeType =&nbsp;<span style="color:#c00000">&quot;sparsetree&quot;</span>;&nbsp;<span style="color:#8080ff">//&quot;gradedtree&quot;;</span><br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     We focus on \(L_2\)-orthonormal wavelets here</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">bool</span>&nbsp;IsMW =&nbsp;<span style="color:#c00000">true</span>;<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">int</span>&nbsp;weightType =&nbsp;<span style="color:#c00000">1</span>;<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">size_t</span>&nbsp;hashMapSize =&nbsp;<span style="color:#c00000">196613</span>;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Size of the underlying domain: \([-2,2] \times [-2,2]\)</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;T left_x1 = -<span style="color:#c00000">2.</span>, right_x1 =&nbsp;<span style="color:#c00000">2.</span>;<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;T left_x2 = -<span style="color:#c00000">2.</span>, right_x2 =&nbsp;<span style="color:#c00000">2.</span>;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Parameter \(\delta\) for error measurement (e.g., Eq. (8.125))</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;T delta =&nbsp;<span style="color:#c00000">0.05</span>;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Parameters for the \(\theta\)-scheme</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;T theta =&nbsp;<span style="color:#c00000">0.5</span>;<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;T timestep_eps =&nbsp;<span style="color:#c00000">1e-2</span>;<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">int</span>&nbsp;maxiterations =&nbsp;&nbsp;<span style="color:#c00000">50</span>;&nbsp;&nbsp;T init_cgtol =&nbsp;<span style="color:#c00000">1e-9</span>;&nbsp;&nbsp;&nbsp;<span style="color:#8080ff">// use maxiterations = 1 for &quot;pure&quot; sparse grid computation</span><br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">int</span>&nbsp;numOfTimesteps =&nbsp;<span style="color:#c00000">128</span>;<br>
<!-- CodeLine     5 -->&nbsp;&nbsp;&nbsp;&nbsp;T timestep = maturity/numOfTimesteps;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Number of MC runs</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">int</span>&nbsp;numOfMCRuns =&nbsp;<span style="color:#c00000">100000</span>;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Integration order for approximating the initial condition</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">int</span>&nbsp;order =&nbsp;<span style="color:#c00000">4</span>;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Read reference prices from file (true) or not (false)</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">bool</span>&nbsp;useRefPrices =&nbsp;<span style="color:#c00000">true</span>;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Basis initialization</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;PrimalBasis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; basis(d,j0);<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;basis.enforceBoundaryCondition&lt;DirichletBC&gt;();<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;RefinementBasis&nbsp;&nbsp;&amp;refinementbasis = basis.refinementbasis;<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;Basis2D basis2d(basis,basis);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Operator initialization. Please see p. 178 for the meaning of \(U\).</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;DenseMatrixT U(<span style="color:#c00000">2</span>,<span style="color:#c00000">2</span>), tU(<span style="color:#c00000">2</span>,<span style="color:#c00000">2</span>), Q(<span style="color:#c00000">2</span>,<span style="color:#c00000">2</span>), QtU(<span style="color:#c00000">2</span>,<span style="color:#c00000">2</span>), UQtU(<span style="color:#c00000">2</span>,<span style="color:#c00000">2</span>);<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;U&nbsp;&nbsp;= u11, u12, u21, u22;<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;tU = u11, u21, u12, u22;<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;Q&nbsp;&nbsp;= sigma1*sigma1, rho*sigma1*sigma2, rho*sigma1*sigma2, sigma2*sigma2;<br>
<!-- CodeLine     5 -->&nbsp;&nbsp;&nbsp;&nbsp;QtU&nbsp;&nbsp;= Q(<span style="color:#c00000">1</span>,<span style="color:#c00000">1</span>)*tU(<span style="color:#c00000">1</span>,<span style="color:#c00000">1</span>)+Q(<span style="color:#c00000">1</span>,<span style="color:#c00000">2</span>)*tU(<span style="color:#c00000">2</span>,<span style="color:#c00000">1</span>), Q(<span style="color:#c00000">1</span>,<span style="color:#c00000">1</span>)*tU(<span style="color:#c00000">1</span>,<span style="color:#c00000">2</span>)+Q(<span style="color:#c00000">1</span>,<span style="color:#c00000">2</span>)*tU(<span style="color:#c00000">2</span>,<span style="color:#c00000">2</span>),<br>
<!-- CodeLine     6 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q(<span style="color:#c00000">2</span>,<span style="color:#c00000">1</span>)*tU(<span style="color:#c00000">1</span>,<span style="color:#c00000">1</span>)+Q(<span style="color:#c00000">2</span>,<span style="color:#c00000">2</span>)*tU(<span style="color:#c00000">2</span>,<span style="color:#c00000">1</span>), Q(<span style="color:#c00000">2</span>,<span style="color:#c00000">1</span>)*tU(<span style="color:#c00000">1</span>,<span style="color:#c00000">2</span>)+Q(<span style="color:#c00000">2</span>,<span style="color:#c00000">2</span>)*tU(<span style="color:#c00000">2</span>,<span style="color:#c00000">2</span>);<br>
<!-- CodeLine     7 -->&nbsp;&nbsp;&nbsp;&nbsp;UQtU = U(<span style="color:#c00000">1</span>,<span style="color:#c00000">1</span>)*QtU(<span style="color:#c00000">1</span>,<span style="color:#c00000">1</span>)+U(<span style="color:#c00000">1</span>,<span style="color:#c00000">2</span>)*QtU(<span style="color:#c00000">2</span>,<span style="color:#c00000">1</span>), U(<span style="color:#c00000">1</span>,<span style="color:#c00000">1</span>)*QtU(<span style="color:#c00000">1</span>,<span style="color:#c00000">2</span>)+U(<span style="color:#c00000">1</span>,<span style="color:#c00000">2</span>)*QtU(<span style="color:#c00000">2</span>,<span style="color:#c00000">2</span>),<br>
<!-- CodeLine     8 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; U(<span style="color:#c00000">2</span>,<span style="color:#c00000">1</span>)*QtU(<span style="color:#c00000">1</span>,<span style="color:#c00000">1</span>)+U(<span style="color:#c00000">2</span>,<span style="color:#c00000">2</span>)*QtU(<span style="color:#c00000">2</span>,<span style="color:#c00000">1</span>), U(<span style="color:#c00000">2</span>,<span style="color:#c00000">1</span>)*QtU(<span style="color:#c00000">1</span>,<span style="color:#c00000">2</span>)+U(<span style="color:#c00000">2</span>,<span style="color:#c00000">2</span>)*QtU(<span style="color:#c00000">2</span>,<span style="color:#c00000">2</span>);<br>
<!-- CodeLine     9 -->&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;&nbsp;<span style="color:#c00000">&quot;U Q U^T &quot;</span>&nbsp;&lt;&lt; UQtU &lt;&lt; endl;<br>
<!-- CodeLine    10 -->&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;&nbsp;<span style="color:#c00000">&quot;s1 = &quot;</span>&nbsp;&lt;&lt; s1 &lt;&lt;&nbsp;<span style="color:#c00000">&quot;, s2 = &quot;</span>&nbsp;&lt;&lt; s2 &lt;&lt; endl;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Definition of the underlying operator (with domain transformation), see Section 8.6.1</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;T a1 =&nbsp;<span style="color:#c00000">0.5</span>*s1/((right_x1-left_x1)*(right_x1-left_x1));<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;T a2 =&nbsp;<span style="color:#c00000">0.5</span>*s2/((right_x1-left_x1)*(right_x1-left_x1));<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;LocalOp1D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localOp1D(basis,basis,refinementbasis.LaplaceOp1D);<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;UniDirectionalLocalOpXOne2D&nbsp;&nbsp;uniDirectionalOpXOne2D(localOp1D, a1);<br>
<!-- CodeLine     5 -->&nbsp;&nbsp;&nbsp;&nbsp;UniDirectionalLocalOpXTwo2D&nbsp;&nbsp;uniDirectionalOpXTwo2D(localOp1D, a2);<br>
<!-- CodeLine     6 -->&nbsp;&nbsp;&nbsp;&nbsp;CompoundLocalOperator2D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localOp2D(uniDirectionalOpXOne2D,uniDirectionalOpXTwo2D);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Initialization of preconditioner</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;NoPreconditioner&lt;T, Index2D&gt; NoPrec;<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;Preconditioner&nbsp;&nbsp;Prec(basis2d, a1, a2,&nbsp;<span style="color:#c00000">1.</span>);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Initialization of integrals for initial condition and rhs</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;Option2D&lt;T,optiontype&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; option2d(optionparameters);<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;option2d.setNumberOfMCRuns(numOfMCRuns);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     This is required for approximating the initial condition with zero boundary conditions</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;TruncatedBasketPutOption2D&lt;T&gt; truncatedoption2d;<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8080ff">//TruncatedSumOfPutsOption2D&lt;T&gt; truncatedoption2d;</span><br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;truncatedoption2d.setOption(option2d);<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;truncatedoption2d.setTransformation(u11, u21, u12, u22);<br>
<!-- CodeLine     5 -->&nbsp;&nbsp;&nbsp;&nbsp;truncatedoption2d.setTruncation(left_x1, right_x1, left_x2, right_x2,&nbsp;<span style="color:#c00000">0</span>,&nbsp;<span style="color:#c00000">0.2</span>,&nbsp;<span style="color:#c00000">200.</span>);<br>
<!-- CodeLine     6 -->&nbsp;&nbsp;&nbsp;&nbsp;truncatedoption2d.setCriticalLine_x1(critical_line_x1, critical_above_x1);<br>
<!-- CodeLine     7 -->&nbsp;&nbsp;&nbsp;&nbsp;PayoffIntegral payoffIntegral(basis2d, truncatedoption2d,<br>
<!-- CodeLine     8 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left_x1, right_x1, left_x2, right_x2,&nbsp;<span style="color:#c00000">true</span>,&nbsp;<span style="color:#c00000">0.05</span>, order);<br>
<!-- CodeLine     9 -->&nbsp;&nbsp;&nbsp;&nbsp;PayoffIntegralRHS payoffIntegralRHS(payoffIntegral, NoPrec);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     The maximum number of AWGM iterations for approximating the initial condition (parameter \(K\) on p. 182.</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">int</span>&nbsp;maxL2Iterations =&nbsp;<span style="color:#c00000">18</span>;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Initialization of the local weighting of residuals defined in Eq. (8.126). Unfortunately, the parameter \(c\) appearing in this equation is hard-coded in this class. Currently, parameters are for the case \(d=2\) (Eq. (8.128))</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalWeightingInitCond2D localWeightingInitCond2D;<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localWeightingInitCond2D.setDomain(left_x1,right_x1,left_x2,right_x2);<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localWeightingInitCond2D.setBasis(&amp;basis2d);<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localWeightingInitCond2D.setWeightType(weightType);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Initializing the solver for approximating the initial condition</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ApproxL2AWGM2D approxL2_solver(basis2d, localThetaTimeStepOp2D, payoffIntegralRHS, NoPrec);<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;approxL2_solver.setParameters(alpha, gamma, residualType, treeType, IsMW,&nbsp;<span style="color:#c00000">false</span>);<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;approxL2_solver.approxL2(u, timestep_eps, localWeightingInitCond2D.weight, maxL2Iterations);<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;&nbsp;<span style="color:#c00000">&quot;Approximation of initial condition finished.&quot;</span>&nbsp;&lt;&lt; endl;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Initialization of multi tree based adaptive wavelet Galerkin method</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThetaTimeStepMultiTreeAWGM2D thetatimestep_solver(basis2d, localThetaTimeStepOp2D,<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thetatimestep_F, Prec);<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thetatimestep_solver.setParameters(alpha, gamma, residualType, treeType, IsMW,&nbsp;<span style="color:#c00000">false</span>,<br>
<!-- CodeLine     4 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hashMapSize);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Means that only thresholding is applied in each iteration. Please the implementation of the thetascheme.solve below.</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">int</span>&nbsp;strategy =&nbsp;<span style="color:#c00000">2</span>;<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Initializing the \(\theta\)-scheme.</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThetaSchemeMultiTreeAWGM2D thetascheme(thetatimestep_solver);<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thetascheme.setParameters(theta, timestep, numOfTimesteps, timestep_eps, maxiterations,<br>
<!-- CodeLine     3 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init_cgtol, strategy);<br>
</span></div><!--code_content-->
</div><!-- code -->
<p >
     Calling the \(\theta\)-scheme solver. Here, \(j\) refer to parameter in Eq. (8.128).</p><div class="code">
<div class="code_content"><span class="code_content">
<!-- CodeLine     1 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#008000">int</span>&nbsp;avDof =&nbsp;<span style="color:#c00000">0</span>, maxDof =&nbsp;<span style="color:#c00000">0.</span>, terminalDof;<br>
<!-- CodeLine     2 -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thetascheme.solve(u, avDof, maxDof, terminalDof, j);<br>
</span></div><!--code_content-->
</div><!-- code -->
<!--
</td>
</tr>
</table>
-->
</div>

</div>
<div id="page_footer"></div>
</div>

<div id="footer">
Copyright &copy; 2011 <a href="http://lawa.sf.net">Alexander Stippler</a>
</div>
</body>
</html>
